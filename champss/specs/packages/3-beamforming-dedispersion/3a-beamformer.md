# Beamformer

Leader : Chia Min
Second : Shiny, Chitrang

## Overview

### New Version (May 2021)

We have a decision to alter the beamforming process to work in batches of pointings rather than in 
a continuous stream of latest intensity data. There are currently three processes that are located 
in the beamformer repository.

PointingStrategist and SkyBeamFormer is updated to be a class object that is initialised with a set 
of processing options. For PointingStrategist, a set of unix utc start and end time, and a set of 
FRB beam rows is the input to select a set of pointings to compute the data required for the 
beamforming process and output them as a list of ActivePointings.

### PointingMapper

The PointingMapper class is used to create the list of pointings for the slow pulsar search project. 
PointingMapper takes in a set of inputs that are used to produce a list of pointings, with the 
following properties as a dictionary:

- RA, Dec
- The FRB beam row that will transit the sky position.
- Maximum line-of-sight DM according to ne2001 and ymw16 Galactic electron density models.
- Maximum DM value to search to along this line-of-sight.
- The number of channels required for the pointing.
- The length of the pointing, in number of time samples.

The pointing list using the current mapping strategy is placed in the same directory as the 
pointing_mapper.py script hosting the PointingMapper class as a json file. PointingMapper is only to 
be used if we want to alter our pointing mapping. During the running of the pipeline, we expect the 
pointing list to be used to be available as a database for all processed to call for.

### PointingStrategist

The PointingStrategiest class is used to create a list of active pointings to process, together with 
their properties. Upon initialisation, PointingStrategiest will load the most recent pointing maps 
generated by PointingMapper, either from sps-databases or from a locally saved map. The function 
get_pointings takes in a start and end time in unix utc format, and a list of FRB beam rows to 
process. This will create a list of pointings that are active within this time frame and provide the 
set of intensity data required by them to form the tracking sky-beams for power spectrum/hhat 
computation. PointingStrategist.get_pointings will do the following work:

- Calculate the start and end RA for each FRB beam row corresponding to the start and end time 
provided.
- Determine the pointings within the pointing map with RA value within the RA range determined to 
activate.
- Determine the start and end time of the active pointings, and the FRB beams required to form the 
sky-beam at roughly 10 seconds intervals by looking for the FRB beam with the highest sensitivity
at the point in time. The start and end time of the active pointings is the time when the pointing 
has x-y poistion of -0.6 < x < 1.0 and y < 40.68.
- Provide the list of active pointings to the SkyBeam class to produce the tracking beams from the 
pointings.
- Provide the list of FRB beam intensity data required to form the set of tracking beams

This will output a list of ActivePointing objects, where individual pointing has the same dictionary, 
but with extra keys of:

- list of FRB beams to be used to form the skybeam
- list of the start time of each FRB beams to be used
- list of the end time of each FRB beams to be used

A second list with a list of intensity data required and their start and end time will also be 
produced.

### SkyBeamFormer

The SkyBeamFormer class is used to form the sky-beams for individual pointings. It will take in the 
dictionary of a active pointing to form the tracking beam using the function from_skybeam post 
initialisation as follow:

- Create a spectra of zeros with shape of (nchans, nsamps) from the dictionary.
- Look for the intensity data required to form the skybeams and add them to the spectra if RFI 
excision is applied on the data.
- Release the spectra for power spectrum/hhat computation when the beamforming process is done.

Special Cases - pointings with very long transit time :
- If the expected length of a pointing is more than a multiple of 480, split the data by that factor
  - e.g 1600s data split into 3 sets of 520s chunks.
  - NOTE : The exact beam length to split has not yet been finalised, but the core idea will be there 
    as we do not want to process a 2 hours long pointing.
- For these pointings, a separate counter is require to note the chunk length and expected number of
chunks so that it will initialise a new array for each chunk instead of marking the pointing as failed.
- Each chunk will have the same (RA, Dec) as they are going to be co-added to the daily power spectrum/
  hhat stack.

## Interfaces

### Input:

##### PointingStrategist

- start and end time to beamform
- FRB beam rows to beamform
- Access to a pointing map (either local to beamformer repo or in database)

##### SkyBeamFormer

- Cleaned L1 data chunks based on what is required by each ActivePointing
  - In blocks corresponding to their original size
- Beam control:
  - For single beam
    - Sky coordinate
    - Current status of beam 
    - Start, end timestamps
  - For the whole process
    - List of pointings required to be formed
  - For intensity data
    - Status of the intensity data requested (Cleaning, Available, Missing)
- NOTE : Current version of SkyBeamFormer does not do any checks for intensity data, if data is missing, 
  the portion of skybeam is just being left empty.

### Output:

##### PointingStrategist

- List of active pointings to be beamform
- List of intensity data required for beamforming

##### SkyBeam

- sky-beams of length `ntime` with `nchan` channels depending on sky position, indexed by their RA, Dec
  - Sky coordinate (RA, Dec)
  - Start timestamp
  - Total length
  - Chunk number (for pointings split to multiple chunks)
  - nchan
  - ntime
  - Spectra[nchan][ntime]
- Currently the sky-beams are written out in filterbank format : 
  - A header as shown in appendix, but only the following are changed for individual sky-beams
    - src_raj = RA in HHMMSS.SSSS string
    - src_decj = Dec in DDMMSS.SSSS string
    - nchans = nchan
    - nsamples = ntime
    - ibeam = beam_row
    - tstart = start timestamp in MJD
    - source_name = J<RA><+/-><DEC> where RA and Dec are in HHMM and DDMM strings
  - A 2D spectra of [nchan][ntime]
  - Currently, the file will be written to <working_directory>/YYYY/MM/DD/<beam_no>/<RA>_<Dec>.fil
  - The filterbank formatted data is readable by the presto dedispersion routine `prepsubband`

### Requirements:
1. FRB beam model, 
2. List of sky position with LoS max DM/channel numbers required and the
   expected length of spectra in multiples of 4096 time samples,
3. Database containing list of intensity data with their beam number, start and 
end time,
4. Database containing missing intensity data,
5. Database of the calibration and RFI fraction of the intensity data.

### Database:
- for each (Sky coordinate, start time, end time, observation date)
  - File path and name recording the samples
  - Fraction of data masked due to RFI
  - The start timestamp of the observation

### Metrics:
- Information about the status of the pointing for the day:
  - completed
  - failed
  - partially completed (for cases where data is split into multiple chunks)
- Expected sensitivity of the sky-beam formed for a particular day based on
  calibration from CHIME/FRB and the RFI fraction of the intensity data.

### Appendix
The layout of the header of a filterbank file is as follow, with encoded string "HEADER_START" before and "HEADER_END" 
after the following fields : 
- nsamples: int32 =int(ntime),
- nchans: int32 =int(nchan),
- fch1: double =freq_top - chan_bw / 2.0,
- foff: double =-1.0 * chan_bw,
- nbeams: int32 =1,
- ibeam: int32 =int(beam),
- nifs: int32 =1,
- tsamp: double =tsamp,
- tstart: double =start_mjd,
- data_type: int32 =1,
- telescope_id: int32 =20,
- machine_id: int32 =20,
- nbits: int32 =int(nbits),
- barycentric: int32 =0,
- pulsarcentric: int32 =0,
- source_name: string ="RA Dec in J- format",
- src_raj: double =srcra.replace(":", ""),
- src_dej: double =srcdec.replace(":", ""),